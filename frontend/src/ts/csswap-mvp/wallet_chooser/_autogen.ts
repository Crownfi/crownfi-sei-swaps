// auto-generated by acetewm
// DO NOT EDIT BY HAND!!
export class WalletButtonRefs {
	private _element: HTMLElement;
	constructor(element: HTMLElement) {
		this._element = element;
	}
}
export class WalletButtonAutogen extends HTMLButtonElement {
	readonly refs: WalletButtonRefs;
	static get observedAttributes() {
		return ["wallet-address"];
	}
	private _attributeWalletAddressValue: string | null = null;
	get walletAddress(): string | null {
		return this._attributeWalletAddressValue;
	}
	set walletAddress(v: string | null) {
		if (v == null) {
			this.removeAttribute("wallet-address");
		}else{
			this.setAttribute("wallet-address", v);
		}
	}
	protected onWalletAddressChanged(oldValue: string | null, newValue: string | null) {
		// To be overridden by child class
	}
	attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null) {
		switch(name) {
			case "wallet-address":
				this._attributeWalletAddressValue = newValue;
				this.onWalletAddressChanged(oldValue, newValue);
				break;
			default:
				// Shouldn't happen
		}
	}
	constructor() {
		super();
		if (this.childElementCount == 0) {
			this.appendChild(
				(document.getElementById("ace-template-wallet-button") as HTMLTemplateElement)
					.content
					.cloneNode(true)
			);
		}
		this.setAttribute("is", "wallet-button"); // allow for easy query selecting
		this.refs = new WalletButtonRefs(this);
	}
	public static registerElement() {
		customElements.define("wallet-button", this, { extends: "button"});
	}
}
export class NetworkSelectorRefs {
	private _element: HTMLElement;
	constructor(element: HTMLElement) {
		this._element = element;
	}
}
export class NetworkSelectorAutogen extends HTMLSelectElement {
	readonly refs: NetworkSelectorRefs;
	constructor() {
		super();
		if (this.childElementCount == 0) {
			this.appendChild(
				(document.getElementById("ace-template-network-selector") as HTMLTemplateElement)
					.content
					.cloneNode(true)
			);
		}
		this.setAttribute("is", "network-selector"); // allow for easy query selecting
		this.refs = new NetworkSelectorRefs(this);
	}
	public static registerElement() {
		customElements.define("network-selector", this, { extends: "select"});
	}
}
export class WalletChoiceRefs {
	private _element: HTMLElement;
	constructor(element: HTMLElement) {
		this._element = element;
	}
	private _img?: HTMLImageElement;
	get img() {
		if (this._img === undefined) {
			this._img = this._element.querySelector("[ace-ref=\"img\"]:not(:not(:scope)[is] *)")!;
		}
		return this._img;
	}
	private _text?: HTMLSpanElement;
	get text() {
		if (this._text === undefined) {
			this._text = this._element.querySelector("[ace-ref=\"text\"]:not(:not(:scope)[is] *)")!;
		}
		return this._text;
	}
}
export class WalletChoiceAutogen extends HTMLButtonElement {
	readonly refs: WalletChoiceRefs;
	static get observedAttributes() {
		return ["icon", "text"];
	}
	private _attributeIconValue: string | null = null;
	get icon(): string | null {
		return this._attributeIconValue;
	}
	set icon(v: string | null) {
		if (v == null) {
			this.removeAttribute("icon");
		}else{
			this.setAttribute("icon", v);
		}
	}
	protected onIconChanged(oldValue: string | null, newValue: string | null) {
		// To be overridden by child class
	}
	private _attributeTextValue: string | null = null;
	get text(): string | null {
		return this._attributeTextValue;
	}
	set text(v: string | null) {
		if (v == null) {
			this.removeAttribute("text");
		}else{
			this.setAttribute("text", v);
		}
	}
	protected onTextChanged(oldValue: string | null, newValue: string | null) {
		// To be overridden by child class
	}
	attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null) {
		switch(name) {
			case "icon":
				this._attributeIconValue = newValue;
				this.onIconChanged(oldValue, newValue);
				break;
			case "text":
				this._attributeTextValue = newValue;
				this.onTextChanged(oldValue, newValue);
				break;
			default:
				// Shouldn't happen
		}
	}
	constructor() {
		super();
		if (this.childElementCount == 0) {
			this.appendChild(
				(document.getElementById("ace-template-wallet-choice") as HTMLTemplateElement)
					.content
					.cloneNode(true)
			);
		}
		this.setAttribute("is", "wallet-choice"); // allow for easy query selecting
		this.refs = new WalletChoiceRefs(this);
	}
	public static registerElement() {
		customElements.define("wallet-choice", this, { extends: "button"});
	}
}
export class WalletModalRefs {
	private _element: HTMLElement;
	constructor(element: HTMLElement) {
		this._element = element;
	}
	private _heading?: HTMLHeadingElement;
	get heading() {
		if (this._heading === undefined) {
			this._heading = this._element.querySelector("[ace-ref=\"heading\"]:not(:not(:scope)[is] *)")!;
		}
		return this._heading;
	}
	private _choices?: HTMLDivElement;
	get choices() {
		if (this._choices === undefined) {
			this._choices = this._element.querySelector("[ace-ref=\"choices\"]:not(:not(:scope)[is] *)")!;
		}
		return this._choices;
	}
	private _cancelButton?: HTMLButtonElement;
	get cancelButton() {
		if (this._cancelButton === undefined) {
			this._cancelButton = this._element.querySelector("[ace-ref=\"cancel-button\"]:not(:not(:scope)[is] *)")!;
		}
		return this._cancelButton;
	}
}
export class WalletModalAutogen extends HTMLDialogElement {
	readonly refs: WalletModalRefs;
	constructor() {
		super();
		if (this.childElementCount == 0) {
			this.appendChild(
				(document.getElementById("ace-template-wallet-modal") as HTMLTemplateElement)
					.content
					.cloneNode(true)
			);
		}
		this.setAttribute("is", "wallet-modal"); // allow for easy query selecting
		this.refs = new WalletModalRefs(this);
	}
	public static registerElement() {
		customElements.define("wallet-modal", this, { extends: "dialog"});
	}
}
