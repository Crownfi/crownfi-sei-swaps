/* eslint-disable */
/**
 * This file was automatically generated by crownfi-sei-sdk-autogen.
 * DO NOT MODIFY IT BY HAND.
 * The Rust definition of the associated structs is the source of truth!!
 */
import {AssetInfo, AstroRouteConfigResponse, AstroRouteCw20HookMsg, AstroRouteExecuteMsg, AstroRouteQueryMsg, AstroRouteSimulateSwapOperationsResponse, AstroRouteSwapOperation, Cw20ReceiveMsg, Decimal, Uint128} from "./types.js";
import {Coin} from "@cosmjs/amino";
import {ExecuteInstruction, WasmExtension} from "@cosmjs/cosmwasm-stargate";
import {QueryClient} from "@cosmjs/stargate";
import {ContractBase} from "@crownfi/sei-utils";
export class AstroRouterContract<Q extends QueryClient & WasmExtension> extends ContractBase<Q> {
	/** Config returns configuration parameters for the contract using a custom [`ConfigResponse`] structure */
	queryConfig(): Promise<AstroRouteConfigResponse> {
		const msg = {"config": {}} satisfies AstroRouteQueryMsg;
		return this.query(msg);
	}
	/** SimulateSwapOperations simulates multi-hop swap operations */
	querySimulateSwapOperations(args: {
		/** The amount of tokens to swap */
		"offer_amount": Uint128,
		/** The swap operations to perform, each swap involving a specific pool */
		"operations": AstroRouteSwapOperation[]
	}): Promise<AstroRouteSimulateSwapOperationsResponse> {
		const msg = {"simulate_swap_operations": args} satisfies AstroRouteQueryMsg;
		return this.query(msg);
	}
	/** Receive receives a message of type [`Cw20ReceiveMsg`] and processes it depending on the received template */
	buildReceiveIx(args: Cw20ReceiveMsg, funds?: Coin[]): ExecuteInstruction {
		const msg = {"receive": args} satisfies AstroRouteExecuteMsg;
		return this.executeIx(msg, funds);
	}
	/** ExecuteSwapOperations processes multiple swaps while mentioning the minimum amount of tokens to receive for the last swap operation */
	buildExecuteSwapOperationsIx(args: {
		"max_spread"?: Decimal | null,
		"minimum_receive"?: Uint128 | null,
		"operations": AstroRouteSwapOperation[],
		"to"?: string | null
	}, funds?: Coin[]): ExecuteInstruction {
		const msg = {"execute_swap_operations": args} satisfies AstroRouteExecuteMsg;
		return this.executeIx(msg, funds);
	}
	/** Internal use ExecuteSwapOperation executes a single swap operation */
	buildExecuteSwapOperationIx(args: {
		"max_spread"?: Decimal | null,
		"operation": AstroRouteSwapOperation,
		"single": boolean,
		"to"?: string | null
	}, funds?: Coin[]): ExecuteInstruction {
		const msg = {"execute_swap_operation": args} satisfies AstroRouteExecuteMsg;
		return this.executeIx(msg, funds);
	}
	/** Internal use AssertMinimumReceive checks that a receiver will get a minimum amount of tokens from a swap */
	buildAssertMinimumReceiveIx(args: {
		"asset_info": AssetInfo,
		"minimum_receive": Uint128,
		"prev_balance": Uint128,
		"receiver": string
	}, funds?: Coin[]): ExecuteInstruction {
		const msg = {"assert_minimum_receive": args} satisfies AstroRouteExecuteMsg;
		return this.executeIx(msg, funds);
	}
	buildExecuteSwapOperationsCw20Ix(tokenContractOrUnifiedDenom: string, amount: string | bigint | number, args: {
		/** Max spread */
		"max_spread"?: Decimal | null,
		/** The minimum amount of tokens to get from a swap */
		"minimum_receive"?: Uint128 | null,
		/** A vector of swap operations */
		"operations": AstroRouteSwapOperation[],
		/** The recipient */
		"to"?: string | null
	}): ExecuteInstruction {
		const msg = {"execute_swap_operations": args} satisfies AstroRouteCw20HookMsg;
		return this.executeIxCw20(msg, tokenContractOrUnifiedDenom, amount);
	}
}
